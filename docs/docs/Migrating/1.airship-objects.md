---
title: From Airship Signals
description: Testing lmfao
slug: from-airship
---

## Airship's API

Airship already has its own networking API:


```ts
// EVENT: (value: string) => void
const someEvent = new NetworkSignal<[value: string]>("SomeEvent");
// FUNCTION: (value: string) => boolean
const someFunction = new NetworkFunction<[value: string], boolean>("SomeFunction"); 

const someEventServer = someEvent.server; // NetworkSignalServer<[value: string]>
const someEventClient = someEvent.client; // NetworkSignalClient<[value: string]>

const someFunctionServer = someFunction.server; // NetworkFunctionServer<[value: string], boolean>
const someFunctionClient = someFunction.client; // NetworkFunctionClient<[value: string], boolean>
```
It's actually relatively simple, however runs into a few issues as base networking solution:

### Drawbacks


- No type validation (you aren't guaranteed to get a string from a client, for example)
- No way to serialize values (this has to be done manually)
- No context hints (technically can invoke both ways, not clear which direction a signal might be firing, or a function being called from)

If you want a more complex networking message, you have to make decisions as to not send too much data over the network. This becomes even more of a problem when you need to send data structures across the network, as keys are included - and strings aren't cheap!

### Sending objects
```ts
type DroppedItemDto = [
    netId: number, // required to be a number
    itemId: number, // the id of the item
    droppedBy: number, // the character id of who dropped
]; // Sending the keys is expensive, so this is usually the "efficient" pattern for this.


export class DroppedItem extends AirshipBehaviour {
    private readonly itemDropped = new NetworkSignal<[droppedItem: DroppedItemDto]>("ItemDropped");

    public networkIdentity: NetworkIdentity;
    public itemId: ItemId; // enum of strings representing the item id
    public droppedBy: Player;
    // ...

    public Init(itemId: ItemId, droppedBy: Player | undefined) {
        // ... 
        
        if (Game.IsServer()) {
            itemDropped.FireAllClients(...this.GetDto());
        }

        // ...
    }

    public GetDto(): DroppedItemDto {
        return [
            this.networkIdentity.netId, // the network identity's id
            Airship.Inventory.GetItemDef(this.item).internalId, // item internal id
            droppedItem.droppedBy.id, // the character's id
        ]
    }
}
```

Each item in the array has to keep track of both the keys, and values. You can imagine the network is sending something like
`[ { userId: "xyz...", level: 10, xp: 0 }, { userId: "abc..."; level: 20, xp: 30 }, ... ]` - where every _key_ is sent (as a string!) as well as their respective values!


## Why Nexus
- Built in type validation
- Built in serialization (Support for `Set<T>`, `Map<K, V>`, Objects, `NetworkIdentity`, `Player`, `Character`, `Team`, and even your own custom serializers...)
- Built in byte encoding (send as bytes)
- Context hinting (server vs client objects)
- A simple drop-in replacement for the default networking
- Builder API for extending events and functions with middleware, setting unreliable, using byte encoding etc.


## Using Nexus

If we go from the above examples:

```ts
// SERVER EVENT: (value: string) => void
const someEvent = Nexus.Server("SomeEvent", Nexus.Event(NexusTypes.String));
// SERVER FUNCTION: (value: string) => boolean
const someFunction = Nexus.Server("SomeFunction", Nexus.Function([ NexusTypes.String ], NexusTypes.Boolean)); 


// All of these still work, albeit with context typings...
const someEventServer = someEvent.server; // ServerSenderEvent<[string]>
const someEventClient = someEvent.client; // ClientListenerEvent<[string]>

const someFunctionServer = someEvent.server; // ServerListenerFunction<[string], boolean>
const someFunctionClient = someEvent.client; // ClientInvokeFunction<[string], boolean>
```

You will notice, _it's a lot more verbose_. This is the static types API. It also, as you will notice - type the accessors of server and client according to what context  you declare the object with.

If we changed our `"SomeEvent"` object to be client-owned, then we'll instead get:
```ts
// SERVER EVENT: (value: string) => void
const someEvent = Nexus.Client("SomeEvent", Nexus.Event(NexusTypes.String));

// All of these still work, albeit with context typings...
const someEventServer = someEvent.server; // ServerListenerEvent<[string]>
const someEventClient = someEvent.client; // ClientSenderEvent<[string]>
```

### Now sending objects...
```ts
interface DroppedItemData { 
    identity: NetworkIdentity, // required to be a number
    itemId: ItemId, // the id of the item!
    droppedBy: Character, // the character id of who dropped
}; // Wow, objects!

const DroppedItemDataType = NexusTypes.Interface<DroppedItemData>({
    identity: NexusTypes.Identity, // will internally serialize to the id
    itemId: NexusTypes.StringEnum(ItemId), // will represent each value as a hash equiv.
    droppedBy: NexusTypes.Character, // will serialize as a string
}); // keys are not used, this is essentially a hash table, imagine it like [ 1, 2323245, 3 ]

export class DroppedItem extends AirshipBehaviour {
    private readonly itemDropped = Nexus.Server(
        "ItemDropped", 
        Nexus.Event(DroppedItemDataType),
    );

    public networkIdentity: NetworkIdentity;
    public itemId: ItemId; // enum of strings representing the item id
    public droppedBy: Character;
    // ...

    public Init(itemId: ItemId, droppedBy: Character | undefined) {
        // ... 
        
        if (Game.IsServer()) {
            itemDropped.SendToAllPlayers(this.GetDto());
        }

        // ...
    }

    public GetDto(): DroppedItemData {
        return {
            identity: this.networkIdentity, // the network identity
            itemId: this.item, // item id
            droppedBy: droppedItem.droppedBy, // the character
        }
    }
}
```